import os
import json
import glob
import cv2
import base64
import numpy as np
from mcap.writer import Writer
import time
from datetime import datetime

COLOR = "color"
DEPTH = "depth"


compressed_image_schema = json.dumps({
    "title": "foxglove.CompressedImage",
    "description": "A compressed image",
    "$comment": "Generated by https://github.com/foxglove/schemas",
    "type": "object",
    "properties": {
        "timestamp": {
            "type": "object",
            "title": "time",
            "properties": {
                "sec": {"type": "integer", "minimum": 0},
                "nsec": {"type": "integer", "minimum": 0, "maximum": 999999999}
            },
            "description": "Timestamp of image"
        },
        "frame_id": {
            "type": "string",
            "description": "Frame of reference for the image."
        },
        "data": {
            "type": "string",
            "contentEncoding": "base64",
            "description": "Compressed image data"
        },
        "format": {
            "type": "string",
            "description": "Image format (png, jpeg, webp, etc.)"
        }
    }
}).encode("utf-8")

def mcap_builder(output_mcap, scene_path):
    with open(output_mcap, "wb") as f:
        writer = Writer(f)
        writer.start()

        image_schema_id = writer.register_schema(
            name="foxglove.CompressedImage",
            encoding="jsonschema",
            data=compressed_image_schema
        )
        camera_dirs = glob.glob(os.path.join(scene_path, "cam_*"))

        for cam_dir in camera_dirs:
            cam_name = os.path.basename(cam_dir)  # Get only "cam_*"
            cam_number = cam_name.replace("cam_", "")

            ts_path = os.path.join(cam_dir, "timestamps.npy")
            timestamps = np.load(ts_path, allow_pickle=True)
            ts_lst = timestamps.item()[COLOR]

            if not ts_lst:
                continue
            cam_path = os.path.join(cam_dir, f"{COLOR}.mp4")
            if not os.path.exists(cam_path):
                continue

            color_channel_id = writer.register_channel(
                topic=f"/camera/{cam_number}/color",
                message_encoding="json",
                schema_id=image_schema_id
            )
            cap = cv2.VideoCapture(cam_path)
            # fps = cap.get(cv2.CAP_PROP_FPS)
            idx = 0
            # frame_count = 0
            while True:
                ret, frame = cap.read()
                if not ret:
                    break  # Stop if video ends
                if not ret or idx >= len(ts_lst):
                    break
                ts = ts_lst[idx]
                # Encode frame as PNG
                success, buffer = cv2.imencode(".png", frame)
                if not success:
                    continue

                # Convert image to base64
                base64_data = base64.b64encode(buffer).decode("utf-8")

                ts = int(ts)

                sec = ts // 1000
                nsec = (ts % 1000) * 1_000_000

                # Prepare the JSON message
                message_data = json.dumps({
                    "timestamp": {"sec": sec, "nsec": nsec},
                    "frame_id": "camera_1",
                    "data": base64_data,
                    "format": "png"
                }).encode("utf-8")

                # Write message to MCAP
                # timestamp = int((start_time + frame_count / fps) * 1e9)
                # timestamp = int((ts_lst[0] + frame_count / fps) * 1_000_000)  # Convert to nanoseconds
                timestamp = ts * 1_000_000   # tranforms to nano
                # timestamp = 1739259420627109632   # tranforms to nano
                writer.add_message(
                    channel_id=color_channel_id,
                    log_time=timestamp,
                    publish_time=timestamp,
                    data=message_data
                )
                idx += 1
                # frame_count += 1
            cap.release()
        writer.finish()


if __name__ == '__main__':
    output_mcap = "task_0004_user_0016_scene_0009_cfg_0003.mcap"
    # scene_path = "raw_data/task_0004_user_0016_scene_0003_cfg_0003"
    scene_path = "raw_data/task_0004_user_0016_scene_0009_cfg_0003"
    mcap_builder(output_mcap, scene_path)
