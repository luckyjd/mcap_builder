import os
import json
import glob
import cv2
import base64
import numpy as np
from mcap.writer import Writer

COLOR = "color"
DEPTH = "depth"


compressed_image_schema = json.dumps({
    "title": "foxglove.CompressedImage",
    "description": "A compressed image",
    "$comment": "Generated by https://github.com/foxglove/schemas",
    "type": "object",
    "properties": {
        "timestamp": {
            "type": "object",
            "title": "time",
            "properties": {
                "sec": {"type": "integer", "minimum": 0},
                "nsec": {"type": "integer", "minimum": 0, "maximum": 999999999}
            },
            "description": "Timestamp of image"
        },
        "frame_id": {
            "type": "string",
            "description": "Frame of reference for the image."
        },
        "data": {
            "type": "string",
            "contentEncoding": "base64",
            "description": "Compressed image data"
        },
        "format": {
            "type": "string",
            "description": "Image format (png, jpeg, webp, etc.)"
        }
    }
}).encode("utf-8")

def mcap_builder(output_mcap, scene_path):
    with open(output_mcap, "wb") as f:
        writer = Writer(f)
        writer.start()

        image_schema_id = writer.register_schema(
            name="foxglove.CompressedImage",
            encoding="jsonschema",
            data=compressed_image_schema
        )
        camera_dirs = glob.glob(os.path.join(scene_path, "cam_*"))

        for cam_dir in camera_dirs:
            cam_name = os.path.basename(cam_dir)  # Get only "cam_*"
            cam_number = cam_name.replace("cam_", "")

            ts_dict = load_camera_timestamps(cam_dir)
            ts_lst = ts_dict[COLOR]

            if not ts_lst:
                continue
            cam_path = os.path.join(cam_dir, f"{COLOR}.mp4")
            if not os.path.exists(cam_path):
                continue

            color_channel_id = writer.register_channel(
                topic=f"/camera/{cam_number}/color",
                message_encoding="json",
                schema_id=image_schema_id
            )
            cap = cv2.VideoCapture(cam_path)
            # fps = cap.get(cv2.CAP_PROP_FPS)
            idx = 0
            # frame_count = 0
            while True:
                ret, frame = cap.read()
                if not ret:
                    break  # Stop if video ends
                if not ret or idx >= len(ts_lst):
                    break
                ts = ts_lst[idx]
                # Encode frame as PNG
                success, buffer = cv2.imencode(".png", frame)
                if not success:
                    continue

                # Convert image to base64
                base64_data = base64.b64encode(buffer).decode("utf-8")

                ts = int(ts)

                sec = ts // 1000
                nsec = (ts % 1000) * 1_000_000

                # Prepare the JSON message
                message_data = json.dumps({
                    "timestamp": {"sec": sec, "nsec": nsec},
                    "frame_id": "camera_1",
                    "data": base64_data,
                    "format": "png"
                }).encode("utf-8")

                # Write message to MCAP
                # timestamp = int((start_time + frame_count / fps) * 1e9)
                # timestamp = int((ts_lst[0] + frame_count / fps) * 1_000_000)  # Convert to nanoseconds
                timestamp = ts * 1_000_000   # tranforms to nano
                # timestamp = 1739259420627109632   # tranforms to nano
                writer.add_message(
                    channel_id=color_channel_id,
                    log_time=timestamp,
                    publish_time=timestamp,
                    data=message_data
                )
                idx += 1
                # frame_count += 1
            cap.release()
        writer.finish()


def load_camera_timestamps(cam_folder):
    ts_path = os.path.join(cam_folder, "timestamps.npy")
    timestamps = np.load(ts_path, allow_pickle=True)
    return timestamps.item()


def add_color_frames_from_cam(writer, cam_folder, timestamps, image_schema_id):
    cam_path = os.path.join(cam_folder, f"{COLOR}.mp4")
    if not os.path.exists(cam_path):
        return
    cam_name = os.path.basename(cam_folder)  # Get only "cam_*"
    cam_number = cam_name.replace("cam_", "")
    color_channel_id = writer.register_channel(
        topic=f"/camera/{cam_number}/color",
        message_encoding="json",
        schema_id=image_schema_id
    )
    ts_lst = timestamps[COLOR]
    cap = cv2.VideoCapture(cam_path)
    # fps = cap.get(cv2.CAP_PROP_FPS)
    idx = 0
    # frame_count = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break  # Stop if video ends
        if not ret or idx >= len(ts_lst):
            break
        ts = ts_lst[idx]
        # Encode frame as PNG
        success, buffer = cv2.imencode(".png", frame)
        if not success:
            continue

        # Convert image to base64
        base64_data = base64.b64encode(buffer).decode("utf-8")

        ts = int(ts)

        sec = ts // 1000
        nsec = (ts % 1000) * 1_000_000

        # Prepare the JSON message
        message_data = json.dumps({
            "timestamp": {"sec": sec, "nsec": nsec},
            "frame_id": "camera_1",
            "data": base64_data,
            "format": "png"
        }).encode("utf-8")

        # Write message to MCAP
        # timestamp = int((start_time + frame_count / fps) * 1e9)
        # timestamp = int((ts_lst[0] + frame_count / fps) * 1_000_000)  # Convert to nanoseconds
        timestamp = ts * 1_000_000  # tranforms to nano
        # timestamp = 1739259420627109632   # tranforms to nano
        writer.add_message(
            channel_id=color_channel_id,
            log_time=timestamp,
            publish_time=timestamp,
            data=message_data
        )
        idx += 1
        # frame_count += 1
    cap.release()


if __name__ == '__main__':
    output_mcap = "output6.mcap"
    # scene_path = "raw_data/task_0004_user_0016_scene_0003_cfg_0003"
    scene_path = "raw_data/task_0001_user_0016_scene_0001_cfg_0003"
    mcap_builder(output_mcap, scene_path)
